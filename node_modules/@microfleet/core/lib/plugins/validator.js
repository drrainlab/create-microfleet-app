"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const validation_1 = require("@microfleet/validation");
const callsite = require("callsite");
const common_errors_1 = require("common-errors");
const path = require("path");
const constants_1 = require("../constants");
/**
 * Plugin name
 */
exports.name = 'validator';
/**
 * Plugin Type
 */
exports.type = constants_1.PluginTypes.essential;
/**
 * Relative priority inside the same plugin group type
 */
exports.priority = 0;
/**
 * Attaches initialized validator based on conf.
 * Provides `validate` and `validateSync` methods.
 * @param conf - Validator Configuration Object.
 * @param parentFile - From which file this plugin was invoked.
 */
exports.attach = function attachValidator(conf, parentFile) {
    const service = this;
    const schemasPath = '../../schemas';
    let validator;
    let schemas;
    if (Array.isArray(conf) || conf === undefined) {
        validator = new validation_1.default(schemasPath);
        schemas = conf;
    }
    else {
        validator = new validation_1.default(schemasPath, conf.filter, conf.ajv);
        schemas = conf.schemas;
    }
    if (schemas) {
        if (!Array.isArray(schemas)) {
            throw new common_errors_1.NotPermittedError('validator schemas must be an array of directories, where json schemas are located');
        }
        // for relative paths
        const stack = callsite();
        // Note that schemas with same file name will be overwritten
        for (const location of schemas) {
            let dir;
            if (!path.isAbsolute(location)) {
                const { length } = stack;
                // filter out the file itself
                let iterator = 0;
                let source = '';
                while (iterator < length && !source) {
                    const call = stack[iterator];
                    const filename = call.getFileName();
                    if ([parentFile, __filename, 'native array.js', null].indexOf(filename) === -1) {
                        source = path.dirname(filename);
                    }
                    iterator += 1;
                }
                dir = path.resolve(source, location);
            }
            else {
                dir = location;
            }
            validator.init(dir);
        }
    }
    // built-in configuration schema
    for (const schema of ['microfleet.core', 'config']) {
        if (validator.ajv.getSchema(schema)) {
            service.config = validator.ifError(schema, service.config);
        }
    }
    // extend service
    service[exports.name] = validator;
    service.validate = validator.validate;
    service.validateSync = validator.validateSync;
    service.ifError = validator.ifError;
};
//# sourceMappingURL=validator.js.map