"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = require("http");
const assert = require("assert");
const __1 = require("..");
const packageInfo_1 = require("../utils/packageInfo");
const semver = require("semver");
const Bluebird = require("bluebird");
const usageError = `
if "prometheus" and "router" plugins are used together - you have to  manually configure router handlers:

const {
  default: metricObservability
} = require('@microfleet/core/lib/plugins/router/extensions/audit/metrics')
config.router.extensions.enabled = ["preRequest", "postResponse"]
config.router.extensions.register = [metricObservability()]

In future we expect to handle it automatically :)
`;
/**
 * Plugin Name
 */
exports.name = 'prometheus';
/**
 * Plugin Type
 */
exports.type = __1.PluginTypes.application;
/**
 * Relative priority inside the same plugin group type
 */
exports.priority = 50;
/**
 * Attaches plugin to the MService class.
 * @param settings - prometheus settings
 */
function attach(opts = {}) {
    const service = this;
    if (service.config.plugins.includes('router')) {
        const extensions = service.router.config.extensions || {};
        assert(extensions.enabled.includes('preRequest') && extensions.enabled.includes('postResponse'), usageError);
    }
    const prometheus = service.prometheus = require('prom-client');
    const { config } = service.ifError(exports.name, opts);
    const { port, path, durationBuckets } = config;
    // register default metrics
    prometheus.register.clear();
    prometheus.collectDefaultMetrics();
    // register service version metric
    createAppVersionMetric(prometheus);
    // register methods latency histogram
    service.metricMicrofleetDuration = createMethodsRequestsMetric(prometheus, durationBuckets);
    // handle metric requests
    const server = http_1.createServer(createMetricHandler(prometheus, path));
    return {
        async connect() {
            let resolve;
            let reject;
            const listen = new Promise((_resolve, _reject) => {
                resolve = _resolve;
                reject = _reject;
            });
            try {
                server.once('listening', resolve);
                server.once('error', reject);
                server.listen(port);
                await listen;
            }
            finally {
                server.removeListener('listening', resolve);
                server.removeListener('error', reject);
            }
        },
        async close() {
            await Bluebird.fromCallback(next => server.close(next));
        },
    };
}
exports.attach = attach;
function createAppVersionMetric(prometheus) {
    let metric = prometheus.register.getSingleMetric('application_version_info');
    if (!metric) {
        const pv = semver.parse(packageInfo_1.getVersion());
        metric = new prometheus.Gauge({
            name: 'application_version_info',
            help: 'application version info',
            labelNames: ['version', 'major', 'minor', 'patch'],
        });
        metric.labels(`v${pv.version}`, pv.major, pv.minor, pv.patch).set(1);
    }
    return metric;
}
function createMethodsRequestsMetric(prometheus, buckets) {
    let metric = prometheus.register.getSingleMetric('microfleet_request_duration_milliseconds');
    if (!metric) {
        metric = new prometheus.Histogram({
            buckets,
            name: 'microfleet_request_duration_milliseconds',
            help: 'duration histogram of microfleet route requests',
            labelNames: ['method', 'route', 'transport', 'statusCode'],
        });
    }
    return metric;
}
function createMetricHandler(prometheus, path) {
    return (req, res) => {
        if (req.method === 'GET' && req.url === path) {
            res.writeHead(200, { 'Content-Type': prometheus.register.contentType });
            res.write(prometheus.register.metrics());
        }
        else {
            res.writeHead(404, { 'Content-Type': prometheus.register.contentType });
            res.write('404 Not Found');
        }
        res.end();
    };
}
//# sourceMappingURL=prometheus.js.map